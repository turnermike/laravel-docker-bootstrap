{"version":3,"sources":["webpack:///webpack/bootstrap b7ca32e6c3792a3c07ac","webpack:///./node_modules/truncatise/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,uBAAuB;;AAEpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,Q","file":"vendor.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 46);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b7ca32e6c3792a3c07ac","(function(exportTo) {\n    \"use strict\";\n\n    var selfClosingTags = [\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"];\n\n    /**\n     * Truncates a given HTML string to the specified length.\n     * @param {string} text This is the HTMl string to be truncated\n     * @param {object} options An options object defining how to truncate\n     *      Default values:\n     *      {\n     *          TruncateBy : 'words',   // Options are 'words', 'characters' or 'paragraphs'\n     *          TruncateLength : 50,    // The count to be used with TruncatedBy\n     *          StripHTML : false,      // Whether or not the truncated text should contain HTML tags\n     *          Strict : true,          // When set to false the truncated text finish at the end of the word\n     *          Suffix : '...'          // Text to be appended to the end of the truncated text\n     *      }\n     * @return {string} This returns the provided string truncated to the\n     *      length provided by the options. HTML tags may be stripped based\n     *      on the given options.\n     */\n    var truncatise = function(text,options) {\n        var options         = options || {},\n            text            = (text || \"\").trim(),\n            truncatedText   = \"\",\n            currentState    = 0,\n            isEndOfWord     = false,\n            isTagOpen       = false,\n            currentTag      = \"\",\n            tagStack        = [],\n            nextChar        = \"\";\n        //Counters\n        var charCounter         = 0,\n            wordCounter         = 0,\n            paragraphCounter    = 0;\n        //currentState values\n        var NOT_TAG         = 0,\n            TAG_START       = 1,\n            TAG_ATTRIBUTES  = 2;\n\n        //Set default values\n        options.TruncateBy      = (options.TruncateBy === undefined\n                                    || typeof options.TruncateBy !==  \"string\"\n                                    || !options.TruncateBy.match(/(word(s)?|character(s)?|paragraph(s)?)/))\n                                ? 'words'\n                                : options.TruncateBy.toLowerCase();\n        options.TruncateLength  = (options.TruncateLength === undefined\n                                    || typeof options.TruncateLength !== \"number\")\n                                ? 50\n                                : options.TruncateLength;\n        options.StripHTML       = (options.StripHTML === undefined\n                                    || typeof options.StripHTML !== \"boolean\")\n                                ? false\n                                : options.StripHTML;\n        options.Strict          = (options.Strict === undefined\n                                    || typeof options.Strict !== \"boolean\")\n                                ? true\n                                : options.Strict;\n        options.Suffix          = (options.Suffix === undefined\n                                    || typeof options.Suffix !== \"string\")\n                                ? '...'\n                                : options.Suffix;\n\n        if(text === \"\" || (text.length <= options.TruncateLength && options.StripHTML === false)){\n            return text;\n        }\n\n        //If not splitting on paragraphs we can quickly remove tags using regex\n        if(options.StripHTML && !options.TruncateBy.match(/(paragraph(s)?)/)){\n            text = String(text).replace(/<!--(.*?)-->/gm, '').replace(/<\\/?[^>]+>/gi, '');\n        }\n        //Remove newline seperating paragraphs\n        text = String(text).replace(/<\\/p>(\\r?\\n)+<p>/gm, '</p><p>');\n        //Replace double newlines with paragraphs\n        if(options.StripHTML && String(text).match(/\\r?\\n\\r?\\n/)){\n            text = String(text).replace(/((.+)(\\r?\\n\\r?\\n|$))/gi, \"<p>$2</p>\");\n        }\n\n        for (var pointer = 0; pointer < text.length; pointer++ ) {\n\n            var currentChar = text[pointer];\n\n            switch(currentChar){\n                case \"<\":\n                    if(currentState === NOT_TAG){\n                        currentState = TAG_START;\n                        currentTag = \"\";\n                    }\n                    if(!options.StripHTML){\n                        truncatedText += currentChar;\n                    }\n                    break;\n                case \">\":\n                    if(currentState === TAG_START || currentState === TAG_ATTRIBUTES){\n                        currentState = NOT_TAG;\n                        currentTag = currentTag.toLowerCase();\n                        if(currentTag === \"/p\"){\n                            paragraphCounter++;\n                            if(options.StripHTML){\n                                truncatedText += \" \";\n                            }\n                        }\n\n                        // Ignore self-closing tags.\n                        if ((selfClosingTags.indexOf(currentTag) === -1) && (selfClosingTags.indexOf(currentTag + '/') === -1)) {\n                            if(currentTag.indexOf(\"/\") >= 0){\n                                tagStack.pop();\n                            } else {\n                                tagStack.push(currentTag);\n                            }\n                        }\n                    }\n                    if(!options.StripHTML){\n                        truncatedText += currentChar;\n                    }\n                    break;\n                case \" \":\n                    if(currentState === TAG_START){\n                        currentState = TAG_ATTRIBUTES;\n                    }\n                    if(currentState === NOT_TAG){\n                        wordCounter++;\n                        charCounter++;\n                    }\n                    if(currentState === NOT_TAG || !options.StripHTML){\n                        truncatedText += currentChar;\n                    }\n                    break;\n                default:\n                    if(currentState === NOT_TAG){\n                        charCounter++;\n                    }\n                    if(currentState === TAG_START){\n                        currentTag += currentChar;\n                    }\n                    if(currentState === NOT_TAG || !options.StripHTML){\n                        truncatedText += currentChar;\n                    }\n                    break;\n            }\n\n            nextChar = text[pointer + 1] || \"\";\n            isEndOfWord = options.Strict ? true : (!currentChar.match(/[a-zA-ZÇ-Ü']/i) || !nextChar.match(/[a-zA-ZÇ-Ü']/i));\n\n            if(options.TruncateBy.match(/word(s)?/i) && options.TruncateLength <= wordCounter){\n                truncatedText = truncatedText.trimRight();\n                break;\n            }\n            if(options.TruncateBy.match(/character(s)?/i) && options.TruncateLength <= charCounter && isEndOfWord){\n                break;\n            }\n            if(options.TruncateBy.match(/paragraph(s)?/i) && options.TruncateLength === paragraphCounter){\n                break;\n            }\n        }\n\n        if(!options.StripHTML && tagStack.length > 0){\n            while(tagStack.length > 0){\n                var tag = tagStack.pop();\n                if(tag!==\"!--\"){\n                    truncatedText += \"</\"+tag+\">\";\n                }\n            }\n        }\n\n        if(pointer < text.length - 1) {\n          if(truncatedText.match(/<\\/p>$/gi)){\n              truncatedText = truncatedText.replace(/(<\\/p>)$/gi, options.Suffix + \"$1\");\n          }else{\n              truncatedText = truncatedText + options.Suffix;\n          }\n        }\n\n        return truncatedText.trim();\n    };\n\n    // Export to node\n    if (typeof module !== 'undefined' && module.exports){\n        return module.exports = truncatise;\n    }\n\n    // Nope, export to the browser instead.\n    exportTo.truncatise = truncatise;\n}(this));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/truncatise/index.js\n// module id = 11\n// module chunks = 0 1"],"sourceRoot":""}